Vertex Shader: "#version 460 core\n\nlayout(location = 0) in vec2 a_Pos;\n\nout vec4 other;\n\nvoid main()\n{\n  gl_Position = vec4(a_Pos, 0.0f, 1.0f);\n  other = 1 - vec4(1.0f, 0.0f, 1.0f, 0.0f);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
Fragment Shader: "#version 460 core\n\nuniform vec2 u_Resolution;\nuniform vec2 u_Mouse;\nuniform float u_Time;\n\nin vec4 other;\nout vec4 o_Color;\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,301.7)),dot(p,vec2(209.5,183.3))))*43758.5453);\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_Resolution.xy;\n    st.x *= u_Resolution.x/u_Resolution.y;\n    vec3 color = vec3(.0);\n\n    // Scale\n    st *= 3.;\n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = 1.;  // minimum distance\n\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n\n            // Random position from current + neighbor place in the grid\n            vec2 point = random2(i_st + neighbor);\n\n// Animate the point\n            point = 0.5 + 0.5*sin(u_Time + 6.2831*point);\n\n// Vector between the pixel and the point\n            vec2 diff = neighbor + point - f_st;\n\n            // Distance to the point\n            float dist = length(diff);\n\n            // Keep the closer distance\n            m_dist = min(m_dist, dist);\n        }\n    }\n\n    // Draw the min distance (distance field)\n    color += m_dist;\n\n    // Draw cell center\n    color += 1.-step(.02, m_dist);\n\n    // Draw grid\n    //color.r += step(.98, f_st.x) + step(.98, f_st.y);\n\n    // Show isolines\n    color -= step(.7,abs(sin(27.0*m_dist)))*.5;\n\n    o_Color = vec4(color,1.0) * other;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"